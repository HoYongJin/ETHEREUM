# EIP712(블록체인 서명 기술)

- 사용자가 "내가 지금 무엇에 서명하는지" 눈으로 보고 확인할 수 있게 해주는 표준
    - Ex. Message: 0x48656c6c6f20576f726c64 --> To: Alice Amount: 100 ETH Item: "Golden Sword" Deadline: 2025-12-31

- 데이터의 구조(Structure)와 내용(Content)을 분리해서 해싱

- 3단계 구조
    1. TypeHash(데이터 구조 정의)
        - 데이터의 스키마(Schema)를 해싱
        - keccak256("Voucher(address buyer,uint256 tokenId)")
        - "Voucher(address buyer,uint256 tokenId)"라는 구조를 가짐
        - 데이터 필드 순서가 바뀌거나 타입이 바뀌면 서명이 깨짐
    2. StructHash = hashStruct(message) (실제 값)
        - TypeHash + Data를 섞어서 해싱
        - keccak256(abi.encode(TypeHash, buyer, tokenId))
        - 실제 데이터: "byer: 0xUser, tokenId: 1"(동적 타입(string, bytes)은 값 자체가 아니라 keccak256(값)을 인코딩)
    3. Domain Separator(영역 구분자)
        - Context 정보들을 섞어서 해싱
        - 이 서명은 이더리움 메인넷(ID:1)의 이 컨트랙트(0xABC...)에서만 유효(다른 체인이나 다른 컨트랙트에서 재사용 공격(Replay Attack) 방지)
        - keccak256(abi.encode(TypeHash, NameHash, VersionHash, ChainId, VerifyingContract))
- Digest(최종 서명에 들어가는 해시값): keccack256("\x19\x01"||DomainSeparator||hashStruct(Message))

- Security Considerations
    - Replay Attacks
        1. Alice가 "Bob에게 1 ETH 줌"이라는 내용에 서명
        2. Bob이 이 서명을 컨트랙트에 제출해서 1 ETH를 받음
        3. Bob이 똑같은 서명을 계속 제출(Alice 지갑이 털릴 때까지)
        4. 해결책: 데이터 구조에 nonce를 포함시켜, 한 번 쓸 때마다 데이터 내용을 강제로 바꿉
    - Frontrunning
        1. 사용자가 서명을 릴레이어(Relayer)에게 보내서 가스비를 대납하게 하려고 함
        2. 공격자가 멤풀(Mempool)에서 이 트랜잭션을 보고, 내용은 똑같은데 "가스비를 더 많이 내는" 트랜잭션으로 복제
        3. 공격 트랜잭션이 먼저 채굴
        1. 단순 실행의 경우: 공격자가 대신 실행해 줘도 결과(토큰 전송)는 같으므로 문제가 없음
        2. 보상이 있는 경우: "이 서명을 실행하는 사람에게 10 GLT를 줌"이라는 로직이 있다면, 공격자가 서명을 가로채서 보상만 챙겨갈 수 있음
        4. 해결책: 실행자(Relayer)를 서명 데이터에 박아버림